# æ•™ç§‘æ›¸ç¿»è¨³ã‚¢ãƒ—ãƒª è¨­è¨ˆæ›¸

## ğŸ“‹ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

### ç›®çš„
Google Gemini APIã‚’æ´»ç”¨ã—ã€æ—¥æœ¬èªæ•™ç§‘æ›¸ï¼ˆæ¨ªæ›¸ããƒ»ç¸¦æ›¸ãï¼‰ã‚’å¤šè¨€èªã«ç¿»è¨³ã™ã‚‹Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹ç™º

### ä¸»è¦æ©Ÿèƒ½
- PDFãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨è§£æï¼ˆGeminiä½¿ç”¨ï¼‰
- OCR + å›³è§£æŠ½å‡ºï¼ˆGemini 2.5 Pro / 3.0 Pro åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ï¼‰
- å¤šè¨€èªç¿»è¨³ï¼ˆGemini Flash / Claude Sonneté¸æŠå¯èƒ½ï¼‰
- å›³è§£ãƒ»ç”»åƒã‚’å«ã‚ãŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿æŒ
- ç¿»è¨³çµæœã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆMarkdown/HTML/PDFï¼‰
- ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œå¯¾å¿œï¼ˆSupabaseä¸è¦ï¼‰

### ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼
- æ—¥æœ¬èªæ•™è‚²é–¢ä¿‚è€…
- æ•™æç¿»è¨³ãŒå¿…è¦ãªæ•™è‚²æ©Ÿé–¢
- å¤šè¨€èªå¯¾å¿œæ•™æã‚’ä½œæˆã—ãŸã„å‡ºç‰ˆç¤¾

---

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### å‡¦ç†ãƒ•ãƒ­ãƒ¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PDFå…¥åŠ›    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Gemini 2.5/3.0 Pro                  â”‚
â”‚ - OCRï¼ˆæ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºï¼‰         â”‚
â”‚ - å›³è§£æ¤œå‡ºãƒ»åˆ‡ã‚Šå–ã‚Š                â”‚
â”‚ - ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè§£æ                    â”‚
â”‚ - æ›¸å­—æ–¹å‘è‡ªå‹•åˆ¤å®š                  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ—¥æœ¬èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ï¼ˆãƒã‚¹ã‚¿ãƒ¼ï¼‰      â”‚
â”‚ - ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„                â”‚
â”‚ - å›³è§£å‚ç…§ãƒ»é…ç½®æƒ…å ±                â”‚
â”‚ - ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±ç­‰ï¼‰    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆé¸æŠå¯èƒ½ï¼‰            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Option 1: Gemini 2.0 Flash      â”‚ â”‚
â”‚ â”‚ - é«˜é€Ÿãƒ»ä½ã‚³ã‚¹ãƒˆ                â”‚ â”‚
â”‚ â”‚ - ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«çµ±åˆæ€§          â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Option 2: Claude Sonnet (æ¨å¥¨)  â”‚ â”‚
â”‚ â”‚ - é«˜å“è³ªãƒ»è‡ªç„¶ãªç¿»è¨³            â”‚ â”‚
â”‚ â”‚ - å°‚é–€ç”¨èªã®ä¸€è²«æ€§              â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¤šè¨€èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³                  â”‚
â”‚ - en / zh / ko / etc.               â”‚
â”‚ - å›³è§£åŸ‹ã‚è¾¼ã¿                      â”‚
â”‚ - HTML/PDFå‡ºåŠ›                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è¨­è¨ˆã®æ ¸å¿ƒåŸå‰‡

1. **ãƒã‚¹ã‚¿ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«æ–¹å¼**
   - OCRã¯1å›ã®ã¿å®Ÿè¡Œï¼ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼‰
   - æ—¥æœ¬èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’ãƒã‚¹ã‚¿ãƒ¼ã¨ã—ã¦ä¿å­˜
   - å…¨è¨€èªãŒåŒã˜ã‚½ãƒ¼ã‚¹ã‹ã‚‰ç”Ÿæˆï¼ˆä¸€è²«æ€§ä¿è¨¼ï¼‰

2. **ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**
   - OCRå‡¦ç†ã¨ç¿»è¨³å‡¦ç†ã‚’å®Œå…¨åˆ†é›¢
   - ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆå¯èƒ½æ€§
   - å¾Œã‹ã‚‰æ–°è¨€èªè¿½åŠ ãŒå®¹æ˜“

3. **å“è³ªå„ªå…ˆ**
   - Gemini 2.5/3.0 Proã§OCRç²¾åº¦å‘ä¸Š
   - æ›¸å­—æ–¹å‘è‡ªå‹•åˆ¤å®šï¼ˆç¸¦æ›¸ããƒ»æ¨ªæ›¸ããƒ»æ··åœ¨ã‚’è‡ªå‹•èªè­˜ï¼‰
   - ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³é¸æŠã§å“è³ªã¨ã‚³ã‚¹ãƒˆã®ãƒãƒ©ãƒ³ã‚¹èª¿æ•´

4. **æŸ”è»Ÿãªãƒ‡ãƒ—ãƒ­ã‚¤**
   - ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œå¯¾å¿œï¼ˆJSONãƒ™ãƒ¼ã‚¹DBï¼‰
   - Supabaseå¯¾å¿œï¼ˆæœ¬ç•ªç’°å¢ƒï¼‰
   - ç’°å¢ƒå¤‰æ•°ã§ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½

---

## ğŸ› ï¸ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
- **Python 3.10+**
- **Google Gemini API**
  - Gemini 2.5 Pro: `gemini-2.5-pro` (ç„¡æ–™æ ã‚ã‚Š)
  - Gemini 3.0 Pro: `gemini-3-pro-preview` (èª²é‡‘å¿…è¦ã€é«˜ç²¾åº¦)
  - Gemini 2.5 Flash: `gemini-2.5-flash` (ç¿»è¨³ç”¨ã€é«˜é€Ÿãƒ»ä½ã‚³ã‚¹ãƒˆ)
  - ç’°å¢ƒå¤‰æ•° `USE_GEMINI_3` ã§2.5/3.0ã‚’åˆ‡ã‚Šæ›¿ãˆ
- **Anthropic Claude API** - ç¿»è¨³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€æ¨å¥¨ï¼‰
  - `claude-sonnet-4-5-20250929`
- **FastAPI** - APIã‚µãƒ¼ãƒãƒ¼ + WebUI
- **Pillow / pdf2image** - PDFç”»åƒåŒ–
- **Markdown / WeasyPrint** - HTML/PDFç”Ÿæˆ

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- **Next.js 14+** (App Router)
- **TypeScript**
- **Tailwind CSS**
- **shadcn/ui** - UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### ã‚¤ãƒ³ãƒ•ãƒ©ãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸

#### ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ï¼ˆé–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç”¨ï¼‰
- **JSONãƒ™ãƒ¼ã‚¹DB** - `storage/database.json`
- **ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸** - `storage/pdfs/`, `storage/documents/`, `storage/figures/`
- Supabaseä¸è¦ã§å³åº§ã«å‹•ä½œå¯èƒ½

#### æœ¬ç•ªç’°å¢ƒãƒ¢ãƒ¼ãƒ‰
- **Vercel** - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°
- **Supabase** - PostgreSQL ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
- **Supabase Storage** - PDF/ç”»åƒä¿å­˜
- **Docker** - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè¡Œç’°å¢ƒï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

### å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹
- **Google Gemini API** (å¿…é ˆ)
- **Anthropic Claude API** (ç¿»è¨³å“è³ªé‡è¦–ã®å ´åˆ)

---

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒ

> **Note**: ä»¥ä¸‹ã®ã‚¹ã‚­ãƒ¼ãƒã¯æœ¬ç•ªç’°å¢ƒï¼ˆSupabaseä½¿ç”¨æ™‚ï¼‰ã®ã‚‚ã®ã§ã™ã€‚
> ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œæ™‚ã¯ `storage/database.json` ã«JSONå½¢å¼ã§ä¿å­˜ã•ã‚Œã€åŒã˜ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æŒã¡ã¾ã™ã€‚

### translation_jobs ãƒ†ãƒ¼ãƒ–ãƒ«
```sql
CREATE TABLE translation_jobs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id),

    -- ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±
    original_filename TEXT NOT NULL,
    pdf_url TEXT NOT NULL,
    page_count INTEGER,

    -- OCRçµæœ
    japanese_markdown_url TEXT,  -- ãƒã‚¹ã‚¿ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«
    layout_metadata JSONB,        -- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±
    figures_data JSONB,            -- å›³è§£ãƒ‡ãƒ¼ã‚¿

    -- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    ocr_status TEXT CHECK (ocr_status IN ('pending', 'processing', 'completed', 'failed')),
    ocr_error TEXT,

    -- ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_translation_jobs_user_id ON translation_jobs(user_id);
CREATE INDEX idx_translation_jobs_ocr_status ON translation_jobs(ocr_status);
```

### translation_outputs ãƒ†ãƒ¼ãƒ–ãƒ«
```sql
CREATE TABLE translation_outputs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    job_id UUID REFERENCES translation_jobs(id) ON DELETE CASCADE,

    -- ç¿»è¨³è¨­å®š
    target_language TEXT NOT NULL,  -- 'en', 'zh', 'ko', etc.
    translator_engine TEXT CHECK (translator_engine IN ('gemini', 'claude')),

    -- ç¿»è¨³çµæœ
    translated_markdown_url TEXT,
    html_url TEXT,
    pdf_url TEXT,

    -- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    error_message TEXT,

    -- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
    translation_duration_seconds REAL,
    token_count INTEGER,
    cost_estimate REAL,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_translation_outputs_job_id ON translation_outputs(job_id);
CREATE INDEX idx_translation_outputs_status ON translation_outputs(status);
```

### figures ãƒ†ãƒ¼ãƒ–ãƒ«
```sql
CREATE TABLE figures (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    job_id UUID REFERENCES translation_jobs(id) ON DELETE CASCADE,

    -- å›³è§£æƒ…å ±
    page_number INTEGER NOT NULL,
    figure_number INTEGER NOT NULL,
    image_url TEXT NOT NULL,

    -- ä½ç½®æƒ…å ±
    bounding_box JSONB,  -- {x, y, width, height}

    -- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
    description TEXT,    -- GeminiãŒç”Ÿæˆã—ãŸèª¬æ˜
    extracted_text TEXT, -- å›³è§£å†…ã®ãƒ†ã‚­ã‚¹ãƒˆ

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_figures_job_id ON figures(job_id);
```

### ãƒ­ãƒ¼ã‚«ãƒ«DB/ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ©Ÿèƒ½ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰

#### ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆlocal_db.pyï¼‰

Supabaseä¸è¦ã§ã‚¢ãƒ—ãƒªã‚’å‹•ä½œã•ã›ã‚‹ãŸã‚ã®JSONãƒ™ãƒ¼ã‚¹DBã€‚

**ç‰¹å¾´**:
- `storage/database.json` ã«å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
- Supabaseäº’æ›ã®APIï¼ˆ`table()`, `insert()`, `select()`, `update()`, `eq()`ï¼‰
- ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•
- è‡ªå‹•çš„ã«IDã€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ä»˜ä¸

**ä½¿ç”¨ä¾‹**:
```python
from app.utils.local_db import get_local_db

db = get_local_db()

# INSERT
db.table('translation_jobs').insert({
    'original_filename': 'sample.pdf',
    'pdf_url': 'path/to/pdf',
    'ocr_status': 'pending'
}).execute()

# SELECT
job = db.table('translation_jobs').select('*').eq('id', job_id).single().execute()

# UPDATE
db.table('translation_jobs').update({
    'ocr_status': 'completed'
}).eq('id', job_id).execute()
```

#### ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆlocal_storage.pyï¼‰

Supabase Storageã®ä»£ã‚ã‚Šã«ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨ã€‚

**ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ **:
```
storage/
â”œâ”€â”€ database.json        # JSONãƒ™ãƒ¼ã‚¹DB
â”œâ”€â”€ pdfs/               # ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸPDF
â”‚   â””â”€â”€ {job_id}/
â”‚       â””â”€â”€ original.pdf
â”œâ”€â”€ documents/          # ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
â”‚   â””â”€â”€ {job_id}/
â”‚       â”œâ”€â”€ master_ja.md
â”‚       â”œâ”€â”€ translated_en.md
â”‚       â””â”€â”€ translated_zh.md
â””â”€â”€ figures/            # æŠ½å‡ºã•ã‚ŒãŸå›³è§£
    â””â”€â”€ {job_id}/
        â”œâ”€â”€ page1_fig1.png
        â””â”€â”€ page1_fig2.png
```

**ä½¿ç”¨ä¾‹**:
```python
from app.utils.local_storage import get_local_storage

storage = get_local_storage()

# ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
storage.from_('pdfs').upload(
    path=f"{job_id}/original.pdf",
    content=pdf_bytes
)

# ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
content = storage.from_('documents').download(
    path=f"{job_id}/master_ja.md"
)

# å…¬é–‹URLå–å¾—ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã®å ´åˆã¯file://ãƒ‘ã‚¹ï¼‰
url = storage.from_('figures').get_public_url(
    path=f"{job_id}/page1_fig1.png"
)
```

#### ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹åˆ‡ã‚Šæ›¿ãˆ

```python
# app/utils/supabase_client.py

if settings.SUPABASE_URL:
    # Supabaseä½¿ç”¨
    supabase = create_client(settings.SUPABASE_URL, settings.SUPABASE_KEY)
else:
    # ãƒ­ãƒ¼ã‚«ãƒ«DB/ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨
    supabase = LocalSupabaseClient()  # local_db + local_storage ã®ãƒ©ãƒƒãƒ‘ãƒ¼
```

---

## ğŸ”§ ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

### 1. PDF â†’ OCRï¼ˆGemini 2.0 Flash Thinkingï¼‰

#### 1.1 PDFå‰å‡¦ç†
```python
# services/pdf_preprocessor.py

from pdf2image import convert_from_path
from PIL import Image
import io

def pdf_to_images(pdf_path: str, dpi: int = 300) -> list[bytes]:
    """
    PDFã‚’é«˜è§£åƒåº¦ç”»åƒã«å¤‰æ›

    Args:
        pdf_path: PDFãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        dpi: è§£åƒåº¦ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ300dpiï¼‰

    Returns:
        å„ãƒšãƒ¼ã‚¸ã®ç”»åƒãƒ‡ãƒ¼ã‚¿ï¼ˆPNGå½¢å¼ãƒã‚¤ãƒˆåˆ—ï¼‰
    """
    images = convert_from_path(pdf_path, dpi=dpi)

    image_bytes_list = []
    for img in images:
        # PNGå½¢å¼ã§ãƒã‚¤ãƒˆåˆ—åŒ–
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        image_bytes_list.append(img_bytes.getvalue())

    return image_bytes_list
```

#### 1.2 Gemini OCRå®Ÿè¡Œ
```python
# services/gemini_ocr_service.py

import google.generativeai as genai
from typing import TypedDict
import base64

class OCRResult(TypedDict):
    page_number: int
    markdown_text: str
    figures: list[dict]
    layout_info: dict

class GeminiOCRService:
    """Gemini 2.5 Proã«ã‚ˆã‚‹OCRã‚µãƒ¼ãƒ“ã‚¹"""

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-pro-latest')

    async def extract_page(
        self,
        image_bytes: bytes,
        page_number: int
    ) -> OCRResult:
        """
        1ãƒšãƒ¼ã‚¸åˆ†ã®OCRå‡¦ç†

        Args:
            image_bytes: ãƒšãƒ¼ã‚¸ç”»åƒ
            page_number: ãƒšãƒ¼ã‚¸ç•ªå·

        Returns:
            OCRçµæœï¼ˆãƒ†ã‚­ã‚¹ãƒˆã€å›³è§£ã€ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±ï¼‰
        """

        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
        prompt = self._build_ocr_prompt()

        # ç”»åƒã‚’Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        image_b64 = base64.b64encode(image_bytes).decode('utf-8')

        # Gemini APIå‘¼ã³å‡ºã—
        response = await self.model.generate_content_async([
            {
                'mime_type': 'image/png',
                'data': image_b64
            },
            prompt
        ])

        # çµæœãƒ‘ãƒ¼ã‚¹
        return self._parse_response(response.text, page_number)

    def _build_ocr_prompt(self) -> str:
        """OCRç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ"""

        return """
ã‚ãªãŸã¯æ—¥æœ¬èªæ•™ç§‘æ›¸ã®OCRå°‚é–€å®¶ã§ã™ã€‚ä»¥ä¸‹ã®ç”»åƒã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚

# æŠ½å‡ºã‚¿ã‚¹ã‚¯

## 1. æ›¸å­—æ–¹å‘ã®è‡ªå‹•åˆ¤å®š
ã¾ãšã€ã“ã®æ•™ç§‘æ›¸ãƒšãƒ¼ã‚¸ã®æ›¸å­—æ–¹å‘ã‚’åˆ¤å®šã—ã¦ãã ã•ã„:
- **ç¸¦æ›¸ã** (vertical): å³ã‹ã‚‰å·¦ã€ä¸Šã‹ã‚‰ä¸‹ã«èª­ã‚€
- **æ¨ªæ›¸ã** (horizontal): å·¦ã‹ã‚‰å³ã€ä¸Šã‹ã‚‰ä¸‹ã«èª­ã‚€
- **æ··åœ¨** (mixed): éƒ¨åˆ†çš„ã«ç•°ãªã‚‹æ–¹å‘ãŒæ··åœ¨ï¼ˆä¾‹: è¦‹å‡ºã—ã¯æ¨ªæ›¸ãã€æœ¬æ–‡ã¯ç¸¦æ›¸ãï¼‰

## 2. ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º
- åˆ¤å®šã—ãŸæ›¸å­—æ–¹å‘ã«å¾“ã£ã¦ã€**æ­£ã—ã„èª­ã¿é †åº**ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
- è¦‹å‡ºã—ã€æœ¬æ–‡ã€ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ã€æ³¨é‡ˆã‚’åŒºåˆ¥
- ãƒ«ãƒ“ï¼ˆãµã‚ŠãŒãªï¼‰ãŒã‚ã‚‹å ´åˆã¯ `{æœ¬æ–‡|ãƒ«ãƒ“}` å½¢å¼ã§è¨˜éŒ²
- Markdownå½¢å¼ã§æ§‹é€ åŒ–ï¼ˆè¦‹å‡ºã—ã¯ #ã€## ãªã©ï¼‰

## 3. å›³è§£ãƒ»ç”»åƒã®æ¤œå‡º
- ã™ã¹ã¦ã®å›³ã€è¡¨ã€å†™çœŸã€ã‚¤ãƒ©ã‚¹ãƒˆã€ã‚°ãƒ©ãƒ•ã‚’æ¤œå‡º
- å„å›³è§£ã«ã¤ã„ã¦ä»¥ä¸‹ã‚’è¨˜éŒ²:
  - **ä½ç½®**: ãƒšãƒ¼ã‚¸å†…ã®ãŠãŠã‚ˆãã®åº§æ¨™ (x, y, width, height)
  - **ç¨®é¡**: photo/illustration/diagram/table/graph
  - **å›³å†…ã®ãƒ†ã‚­ã‚¹ãƒˆ**: ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ã€ãƒ©ãƒ™ãƒ«ã€å‡¡ä¾‹ç­‰
  - **ç°¡æ½”ãªèª¬æ˜**: å›³ãŒä½•ã‚’ç¤ºã—ã¦ã„ã‚‹ã‹

## 4. ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±
- æ®µçµ„ã¿æ•°ï¼ˆ1æ®µã€2æ®µã€3æ®µç­‰ï¼‰
- ãƒ†ã‚­ã‚¹ãƒˆã¨å›³è§£ã®é…ç½®é–¢ä¿‚
- ç‰¹æ®Šãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¦ç´ ï¼ˆå›²ã¿è¨˜äº‹ã€ã‚³ãƒ©ãƒ ã€æ³¨é‡ˆãƒœãƒƒã‚¯ã‚¹ç­‰ï¼‰

# å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

ä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„:

```json
{
  "detected_writing_mode": "vertical|horizontal|mixed",
  "markdown_text": "æŠ½å‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆï¼ˆMarkdownå½¢å¼ï¼‰",
  "figures": [
    {
      "id": 1,
      "position": {"x": 100, "y": 200, "width": 400, "height": 300},
      "type": "photo|illustration|diagram|table|graph",
      "description": "å›³ã®èª¬æ˜",
      "extracted_text": "å›³å†…ã®ãƒ†ã‚­ã‚¹ãƒˆï¼ˆã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ç­‰ï¼‰"
    }
  ],
  "layout_info": {
    "primary_direction": "vertical|horizontal",
    "columns": 1,
    "has_ruby": true|false,
    "special_elements": ["å›²ã¿è¨˜äº‹", "æ³¨é‡ˆ"],
    "mixed_regions": [
      {
        "region": "header",
        "direction": "horizontal"
      }
    ]
  }
}
```

# é‡è¦ãªæ³¨æ„äº‹é …

1. **èª­ã¿é †åºã®æ­£ç¢ºæ€§**: æ›¸å­—æ–¹å‘ã‚’æ­£ã—ãåˆ¤å®šã—ã€ãã®æ–¹å‘ã«å¾“ã£ã¦èª­ã¿é †åºã‚’å³å¯†ã«å®ˆã‚‹ã“ã¨
2. **å›³è§£ã®ä½ç½®ç²¾åº¦**: å›³è§£ã®ä½ç½®ã‚’å¯èƒ½ãªé™ã‚Šæ­£ç¢ºã«è¨˜éŒ²ã™ã‚‹ã“ã¨
3. **ãƒ«ãƒ“ãƒ»ç‰¹æ®Šè¨˜å·**: ãƒ«ãƒ“ã€ç¸¦ä¸­æ¨ªã€ç‰¹æ®Šè¨˜å·ã‚‚æ­£ç¢ºã«æŠ½å‡ºã™ã‚‹ã“ã¨
4. **ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å¿ å®Ÿæ€§**: å…ƒã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ§‹é€ ï¼ˆè¦‹å‡ºã—éšå±¤ã€æ®µè½åˆ†ã‘ç­‰ï¼‰ã‚’ç¶­æŒã™ã‚‹ã“ã¨
"""

    def _parse_response(self, response_text: str, page_number: int) -> OCRResult:
        """Geminiå¿œç­”ã‚’ãƒ‘ãƒ¼ã‚¹"""

        import json
        import re

        # JSONãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)

        if not json_match:
            raise ValueError("Failed to parse Gemini response")

        data = json.loads(json_match.group(1))

        return OCRResult(
            page_number=page_number,
            markdown_text=data['markdown_text'],
            figures=data.get('figures', []),
            layout_info=data.get('layout_info', {})
        )

    async def extract_figures_from_image(
        self,
        image_bytes: bytes,
        figure_positions: list[dict]
    ) -> list[bytes]:
        """
        å›³è§£ã‚’ç”»åƒã‹ã‚‰åˆ‡ã‚Šå–ã‚Š

        Args:
            image_bytes: ãƒšãƒ¼ã‚¸å…¨ä½“ã®ç”»åƒ
            figure_positions: å›³è§£ã®ä½ç½®æƒ…å ±ãƒªã‚¹ãƒˆ

        Returns:
            åˆ‡ã‚Šå–ã‚‰ã‚ŒãŸå›³è§£ç”»åƒã®ãƒªã‚¹ãƒˆ
        """
        from PIL import Image
        import io

        # ç”»åƒã‚’é–‹ã
        img = Image.open(io.BytesIO(image_bytes))

        cropped_figures = []

        for fig_pos in figure_positions:
            # ä½ç½®æƒ…å ±å–å¾—
            box = fig_pos['position']

            # åˆ‡ã‚Šå–ã‚Š
            cropped = img.crop((
                box['x'],
                box['y'],
                box['x'] + box['width'],
                box['y'] + box['height']
            ))

            # ãƒã‚¤ãƒˆåˆ—åŒ–
            cropped_bytes = io.BytesIO()
            cropped.save(cropped_bytes, format='PNG')
            cropped_figures.append(cropped_bytes.getvalue())

        return cropped_figures
```

#### 1.3 OCRã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
```python
# services/ocr_orchestrator.py

from typing import List
import asyncio

class OCROrchestrator:
    """OCRå‡¦ç†å…¨ä½“ã®ç®¡ç†"""

    def __init__(self, gemini_service: GeminiOCRService, supabase_client):
        self.gemini = gemini_service
        self.supabase = supabase_client

    async def process_pdf(
        self,
        job_id: str,
        pdf_path: str
    ) -> str:
        """
        PDFå…¨ä½“ã®OCRå‡¦ç†

        Returns:
            æ—¥æœ¬èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®URL
        """

        # 1. PDFã‚’ç”»åƒåŒ–
        page_images = pdf_to_images(pdf_path)

        # 2. å„ãƒšãƒ¼ã‚¸ã‚’OCRï¼ˆä¸¦åˆ—å‡¦ç†ï¼‰
        ocr_tasks = [
            self.gemini.extract_page(img, i+1)
            for i, img in enumerate(page_images)
        ]

        ocr_results = await asyncio.gather(*ocr_tasks)

        # 3. ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³çµ±åˆ
        full_markdown = self._merge_markdown(ocr_results)

        # 4. å›³è§£ã‚’åˆ‡ã‚Šå–ã£ã¦Storageã«ä¿å­˜
        await self._process_figures(job_id, page_images, ocr_results)

        # 5. ãƒã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’Storageã«ä¿å­˜
        markdown_url = await self._save_markdown(job_id, full_markdown)

        # 6. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’DBã«ä¿å­˜
        await self._save_metadata(job_id, ocr_results)

        return markdown_url

    def _merge_markdown(self, ocr_results: List[OCRResult]) -> str:
        """å„ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’çµ±åˆ"""

        markdown_parts = []

        for result in ocr_results:
            markdown_parts.append(f"# ãƒšãƒ¼ã‚¸ {result['page_number']}\n\n")
            markdown_parts.append(result['markdown_text'])
            markdown_parts.append("\n\n")

            # å›³è§£å‚ç…§ã‚’æŒ¿å…¥
            for fig in result['figures']:
                markdown_parts.append(
                    f"![å›³{fig['id']}](figures/page{result['page_number']}_fig{fig['id']}.png)\n\n"
                )
                if fig.get('description'):
                    markdown_parts.append(f"*{fig['description']}*\n\n")

        return ''.join(markdown_parts)

    async def _process_figures(
        self,
        job_id: str,
        page_images: list[bytes],
        ocr_results: List[OCRResult]
    ):
        """å›³è§£ã‚’åˆ‡ã‚Šå–ã‚Šã€Storageã«ä¿å­˜ã€DBã«è¨˜éŒ²"""

        for result in ocr_results:
            page_num = result['page_number']
            page_image = page_images[page_num - 1]

            if not result['figures']:
                continue

            # å›³è§£ã‚’åˆ‡ã‚Šå–ã‚Š
            figure_images = await self.gemini.extract_figures_from_image(
                page_image,
                result['figures']
            )

            # å„å›³è§£ã‚’ä¿å­˜
            for fig, fig_img in zip(result['figures'], figure_images):
                # Supabase Storageã«ä¿å­˜
                file_path = f"{job_id}/figures/page{page_num}_fig{fig['id']}.png"
                image_url = self.supabase.storage.from_('figures').upload(
                    file_path,
                    fig_img
                )

                # DBã«è¨˜éŒ²
                self.supabase.table('figures').insert({
                    'job_id': job_id,
                    'page_number': page_num,
                    'figure_number': fig['id'],
                    'image_url': image_url,
                    'bounding_box': fig['position'],
                    'description': fig.get('description'),
                    'extracted_text': fig.get('extracted_text')
                }).execute()

    async def _save_markdown(self, job_id: str, markdown: str) -> str:
        """ãƒã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’Storageã«ä¿å­˜"""

        file_path = f"{job_id}/master_ja.md"
        url = self.supabase.storage.from_('documents').upload(
            file_path,
            markdown.encode('utf-8')
        )
        return url

    async def _save_metadata(self, job_id: str, ocr_results: List[OCRResult]):
        """ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±ç­‰ã‚’DBã«ä¿å­˜"""

        layout_metadata = {
            'page_count': len(ocr_results),
            'pages': [r['layout_info'] for r in ocr_results]
        }

        self.supabase.table('translation_jobs').update({
            'layout_metadata': layout_metadata,
            'page_count': len(ocr_results),
            'ocr_status': 'completed'
        }).eq('id', job_id).execute()
```

---

### 2. ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆé¸æŠå¯èƒ½ï¼‰

#### 2.1 ç¿»è¨³ã‚µãƒ¼ãƒ“ã‚¹æŠ½è±¡åŒ–
```python
# services/translator_base.py

from abc import ABC, abstractmethod

class TranslatorBase(ABC):
    """ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""

    @abstractmethod
    async def translate(
        self,
        source_text: str,
        target_language: str,
        context: dict = None
    ) -> str:
        """
        ãƒ†ã‚­ã‚¹ãƒˆç¿»è¨³

        Args:
            source_text: æ—¥æœ¬èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³
            target_language: ç¿»è¨³å…ˆè¨€èªã‚³ãƒ¼ãƒ‰ (en, zh, ko, etc.)
            context: è¿½åŠ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±ç­‰ï¼‰

        Returns:
            ç¿»è¨³ã•ã‚ŒãŸãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³
        """
        pass
```

#### 2.2 Claudeç¿»è¨³å®Ÿè£…
```python
# services/claude_translator.py

from anthropic import AsyncAnthropic
from .translator_base import TranslatorBase

class ClaudeTranslator(TranslatorBase):
    """Claude Sonnetã«ã‚ˆã‚‹ç¿»è¨³"""

    LANGUAGE_NAMES = {
        'en': 'English',
        'zh': 'ç®€ä½“ä¸­æ–‡',
        'zh-TW': 'ç¹é«”ä¸­æ–‡',
        'ko': 'í•œêµ­ì–´',
        'vi': 'Tiáº¿ng Viá»‡t',
        'th': 'à¹„à¸—à¸¢',
        'es': 'EspaÃ±ol',
        'fr': 'FranÃ§ais'
    }

    def __init__(self, api_key: str):
        self.client = AsyncAnthropic(api_key=api_key)
        self.model = "claude-sonnet-4-5-20250929"

    async def translate(
        self,
        source_text: str,
        target_language: str,
        context: dict = None
    ) -> str:
        """Claude Sonnetã§ç¿»è¨³"""

        target_lang_name = self.LANGUAGE_NAMES.get(target_language, target_language)

        prompt = f"""
ã‚ãªãŸã¯æ•™è‚²æ•™æã®ç¿»è¨³å°‚é–€å®¶ã§ã™ã€‚

ä»¥ä¸‹ã®æ—¥æœ¬èªæ•™ç§‘æ›¸ã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’{target_lang_name}ã«ç¿»è¨³ã—ã¦ãã ã•ã„ã€‚

# ç¿»è¨³æ™‚ã®é‡è¦äº‹é …

1. **æ•™è‚²çš„æ–‡è„ˆã®ä¿æŒ**
   - å­¦ç¿’è€…ãŒç†è§£ã—ã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ç”¨
   - å°‚é–€ç”¨èªã¯æ­£ç¢ºã«ç¿»è¨³

2. **ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ä¿æŒ**
   - Markdownå½¢å¼ã‚’ãã®ã¾ã¾ç¶­æŒ
   - è¦‹å‡ºã—ï¼ˆ#ï¼‰ã€ãƒªã‚¹ãƒˆã€å¼·èª¿ç­‰ã®æ§‹é€ ã‚’ä¿æŒ
   - å›³è§£å‚ç…§ï¼ˆ`![å›³1](...)`ï¼‰ã¯å¤‰æ›´ã—ãªã„

3. **ä¸€è²«æ€§**
   - ç”¨èªã®çµ±ä¸€
   - æ–‡ä½“ã®çµ±ä¸€

4. **å›³è§£å‚ç…§**
   - ã€Œå›³1å‚ç…§ã€ãªã©ã®è¡¨ç¾ã¯ç¿»è¨³ã™ã‚‹ãŒã€ç”»åƒãƒªãƒ³ã‚¯ã¯å¤‰æ›´ã—ãªã„

5. **ç‰¹æ®Šè¨˜å·**
   - ãƒ«ãƒ“ï¼ˆ`{{æœ¬æ–‡|ãƒ«ãƒ“}}`ï¼‰ã¯ç¿»è¨³å¾Œå‰Šé™¤ã¾ãŸã¯ç¿»è¨³

# ç¿»è¨³å¯¾è±¡ãƒ†ã‚­ã‚¹ãƒˆ

{source_text}

# å‡ºåŠ›

{target_lang_name}ã«ç¿»è¨³ã•ã‚ŒãŸãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®ã¿ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚èª¬æ˜ã‚„æ³¨é‡ˆã¯ä¸è¦ã§ã™ã€‚
"""

        response = await self.client.messages.create(
            model=self.model,
            max_tokens=8000,
            messages=[{
                "role": "user",
                "content": prompt
            }]
        )

        return response.content[0].text
```

#### 2.3 Geminiç¿»è¨³å®Ÿè£…
```python
# services/gemini_translator.py

import google.generativeai as genai
from .translator_base import TranslatorBase

class GeminiTranslator(TranslatorBase):
    """Gemini 2.5 Flashã«ã‚ˆã‚‹ç¿»è¨³"""

    LANGUAGE_NAMES = {
        'en': 'English',
        'zh': 'Simplified Chinese (ç®€ä½“ä¸­æ–‡)',
        'zh-TW': 'Traditional Chinese (ç¹é«”ä¸­æ–‡)',
        'ko': 'Korean (í•œêµ­ì–´)',
        'vi': 'Vietnamese (Tiáº¿ng Viá»‡t)',
        'th': 'Thai (à¹„à¸—à¸¢)',
        'es': 'Spanish (EspaÃ±ol)',
        'fr': 'French (FranÃ§ais)'
    }

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash-latest')

    async def translate(
        self,
        source_text: str,
        target_language: str,
        context: dict = None
    ) -> str:
        """Gemini Flashã§ç¿»è¨³"""

        target_lang_name = self.LANGUAGE_NAMES.get(target_language, target_language)

        prompt = f"""
You are an expert translator specializing in educational materials.

Translate the following Japanese textbook markdown content into {target_lang_name}.

# Translation Guidelines

1. **Maintain Educational Context**
   - Use clear, student-friendly language
   - Translate technical terms accurately

2. **Preserve Formatting**
   - Keep all Markdown formatting intact
   - Maintain headings (#), lists, emphasis, etc.
   - DO NOT modify image references (`![Figure 1](...)`)

3. **Consistency**
   - Use consistent terminology throughout
   - Maintain consistent tone

4. **Figure References**
   - Translate phrases like "See Figure 1" but keep image links unchanged

5. **Special Notations**
   - Ruby annotations (`{{text|ruby}}`) should be removed or adapted as appropriate

# Source Text

{source_text}

# Output

Provide ONLY the translated markdown in {target_lang_name}. No explanations or comments.
"""

        response = await self.model.generate_content_async(prompt)
        return response.text
```

#### 2.4 ç¿»è¨³ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
```python
# services/translation_orchestrator.py

from .claude_translator import ClaudeTranslator
from .gemini_translator import GeminiTranslator
from typing import Literal

TranslatorEngine = Literal['claude', 'gemini']

class TranslationOrchestrator:
    """ç¿»è¨³å‡¦ç†ã®ç®¡ç†"""

    def __init__(
        self,
        claude_api_key: str,
        gemini_api_key: str,
        supabase_client
    ):
        self.claude = ClaudeTranslator(claude_api_key)
        self.gemini = GeminiTranslator(gemini_api_key)
        self.supabase = supabase_client

    async def translate_document(
        self,
        job_id: str,
        target_language: str,
        translator_engine: TranslatorEngine = 'claude'
    ) -> str:
        """
        æ–‡æ›¸å…¨ä½“ã‚’ç¿»è¨³

        Args:
            job_id: ç¿»è¨³ã‚¸ãƒ§ãƒ–ID
            target_language: ç¿»è¨³å…ˆè¨€èª
            translator_engine: ä½¿ç”¨ã™ã‚‹ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³

        Returns:
            ç¿»è¨³æ¸ˆã¿ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®URL
        """

        # 1. ãƒã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’å–å¾—
        job = self.supabase.table('translation_jobs').select('*').eq('id', job_id).single().execute()
        master_md_url = job.data['japanese_markdown_url']
        master_text = self._download_text(master_md_url)

        # 2. ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³é¸æŠ
        translator = self.claude if translator_engine == 'claude' else self.gemini

        # 3. ç¿»è¨³å®Ÿè¡Œ
        translated_text = await translator.translate(
            master_text,
            target_language,
            context=job.data.get('layout_metadata')
        )

        # 4. ç¿»è¨³çµæœã‚’ä¿å­˜
        translated_url = await self._save_translation(
            job_id,
            target_language,
            translated_text
        )

        # 5. DBã«è¨˜éŒ²
        await self._record_translation(
            job_id,
            target_language,
            translator_engine,
            translated_url
        )

        return translated_url

    def _download_text(self, url: str) -> str:
        """Storage ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"""
        # å®Ÿè£…çœç•¥
        pass

    async def _save_translation(
        self,
        job_id: str,
        language: str,
        text: str
    ) -> str:
        """ç¿»è¨³ã‚’Storageã«ä¿å­˜"""

        file_path = f"{job_id}/translated_{language}.md"
        url = self.supabase.storage.from_('documents').upload(
            file_path,
            text.encode('utf-8')
        )
        return url

    async def _record_translation(
        self,
        job_id: str,
        language: str,
        engine: TranslatorEngine,
        translated_url: str
    ):
        """ç¿»è¨³çµæœã‚’DBã«è¨˜éŒ²"""

        self.supabase.table('translation_outputs').insert({
            'job_id': job_id,
            'target_language': language,
            'translator_engine': engine,
            'translated_markdown_url': translated_url,
            'status': 'completed'
        }).execute()
```

---

### 3. APIè¨­è¨ˆ

#### 3.1 PDFã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
```python
# api/upload.py

from fastapi import APIRouter, UploadFile, File, Form, BackgroundTasks
from uuid import uuid4

router = APIRouter()

@router.post("/upload")
async def upload_pdf(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """
    PDFã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼†OCRé–‹å§‹

    Args:
        file: PDFãƒ•ã‚¡ã‚¤ãƒ«

    Returns:
        ã‚¸ãƒ§ãƒ–ID

    Note:
        æ›¸å­—æ–¹å‘ï¼ˆç¸¦æ›¸ã/æ¨ªæ›¸ãï¼‰ã¯GeminiãŒè‡ªå‹•åˆ¤å®šã—ã¾ã™
    """

    # ã‚¸ãƒ§ãƒ–IDç”Ÿæˆ
    job_id = str(uuid4())

    # PDFã‚’Storageã«ä¿å­˜
    pdf_path = f"{job_id}/original.pdf"
    pdf_url = supabase.storage.from_('pdfs').upload(pdf_path, file.file)

    # DBã«ã‚¸ãƒ§ãƒ–ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆ
    supabase.table('translation_jobs').insert({
        'id': job_id,
        'original_filename': file.filename,
        'pdf_url': pdf_url,
        'ocr_status': 'pending'
    }).execute()

    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§OCRé–‹å§‹
    background_tasks.add_task(
        run_ocr_task,
        job_id,
        pdf_path
    )

    return {
        'job_id': job_id,
        'status': 'pending',
        'message': 'OCR processing started (writing direction will be auto-detected)'
    }

async def run_ocr_task(job_id: str, pdf_path: str):
    """ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰OCRã‚¿ã‚¹ã‚¯"""

    try:
        # OCRå®Ÿè¡Œï¼ˆæ›¸å­—æ–¹å‘ã¯è‡ªå‹•åˆ¤å®šï¼‰
        orchestrator = OCROrchestrator(gemini_service, supabase)
        markdown_url = await orchestrator.process_pdf(job_id, pdf_path)

        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        supabase.table('translation_jobs').update({
            'ocr_status': 'completed',
            'japanese_markdown_url': markdown_url
        }).eq('id', job_id).execute()

    except Exception as e:
        # ã‚¨ãƒ©ãƒ¼è¨˜éŒ²
        supabase.table('translation_jobs').update({
            'ocr_status': 'failed',
            'ocr_error': str(e)
        }).eq('id', job_id).execute()
```

#### 3.2 ç¿»è¨³é–‹å§‹
```python
# api/translate.py

from fastapi import APIRouter, BackgroundTasks
from pydantic import BaseModel

router = APIRouter()

class TranslateRequest(BaseModel):
    job_id: str
    target_language: str  # 'en', 'zh', 'ko', etc.
    translator_engine: TranslatorEngine = 'claude'  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆClaude

@router.post("/translate")
async def start_translation(
    request: TranslateRequest,
    background_tasks: BackgroundTasks
):
    """
    ç¿»è¨³é–‹å§‹

    Args:
        job_id: OCRå®Œäº†æ¸ˆã¿ã®ã‚¸ãƒ§ãƒ–ID
        target_language: ç¿»è¨³å…ˆè¨€èª
        translator_engine: 'claude' ã¾ãŸã¯ 'gemini'

    Returns:
        ç¿»è¨³å‡ºåŠ›ID
    """

    # ã‚¸ãƒ§ãƒ–ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
    job = supabase.table('translation_jobs').select('*').eq('id', request.job_id).single().execute()

    if job.data['ocr_status'] != 'completed':
        return {
            'error': 'OCR not completed yet',
            'ocr_status': job.data['ocr_status']
        }, 400

    # ç¿»è¨³å‡ºåŠ›ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆ
    output_id = str(uuid4())
    supabase.table('translation_outputs').insert({
        'id': output_id,
        'job_id': request.job_id,
        'target_language': request.target_language,
        'translator_engine': request.translator_engine,
        'status': 'pending'
    }).execute()

    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ç¿»è¨³é–‹å§‹
    background_tasks.add_task(
        run_translation_task,
        output_id,
        request.job_id,
        request.target_language,
        request.translator_engine
    )

    return {
        'output_id': output_id,
        'status': 'pending',
        'message': 'Translation started'
    }

async def run_translation_task(
    output_id: str,
    job_id: str,
    target_language: str,
    translator_engine: TranslatorEngine
):
    """ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç¿»è¨³ã‚¿ã‚¹ã‚¯"""

    try:
        orchestrator = TranslationOrchestrator(
            claude_api_key=settings.CLAUDE_API_KEY,
            gemini_api_key=settings.GEMINI_API_KEY,
            supabase_client=supabase
        )

        translated_url = await orchestrator.translate_document(
            job_id,
            target_language,
            translator_engine
        )

        supabase.table('translation_outputs').update({
            'status': 'completed',
            'translated_markdown_url': translated_url
        }).eq('id', output_id).execute()

    except Exception as e:
        supabase.table('translation_outputs').update({
            'status': 'failed',
            'error_message': str(e)
        }).eq('id', output_id).execute()
```

#### 3.3 ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
```python
# api/status.py

from fastapi import APIRouter

router = APIRouter()

@router.get("/jobs/{job_id}")
async def get_job_status(job_id: str):
    """
    ã‚¸ãƒ§ãƒ–ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—
    """

    job = supabase.table('translation_jobs').select('*').eq('id', job_id).single().execute()

    # ç¿»è¨³å‡ºåŠ›ä¸€è¦§ã‚‚å–å¾—
    outputs = supabase.table('translation_outputs').select('*').eq('job_id', job_id).execute()

    return {
        'job': job.data,
        'translations': outputs.data
    }

@router.get("/outputs/{output_id}")
async def get_output_status(output_id: str):
    """
    ç¿»è¨³å‡ºåŠ›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—
    """

    output = supabase.table('translation_outputs').select('*').eq('id', output_id).single().execute()

    return output.data
```

#### 3.4 ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
```python
# api/download.py

from fastapi import APIRouter
from fastapi.responses import FileResponse, StreamingResponse

router = APIRouter()

@router.get("/download/{output_id}/markdown")
async def download_markdown(output_id: str):
    """
    ç¿»è¨³æ¸ˆã¿ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    """

    output = supabase.table('translation_outputs').select('*').eq('id', output_id).single().execute()

    if output.data['status'] != 'completed':
        return {'error': 'Translation not completed'}, 400

    # Storageã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    markdown_content = supabase.storage.from_('documents').download(
        output.data['translated_markdown_url']
    )

    return StreamingResponse(
        io.BytesIO(markdown_content),
        media_type='text/markdown',
        headers={
            'Content-Disposition': f'attachment; filename="translated_{output.data["target_language"]}.md"'
        }
    )
```

---

## ğŸ“‚ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ 

```
textbook-translation/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ main.py                          # FastAPIã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ config.py                        # è¨­å®šç®¡ç†
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ upload.py                    # PDFã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
â”‚   â”‚   â”‚   â”œâ”€â”€ translate.py                 # ç¿»è¨³é–‹å§‹
â”‚   â”‚   â”‚   â”œâ”€â”€ status.py                    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
â”‚   â”‚   â”‚   â””â”€â”€ download.py                  # ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ pdf_preprocessor.py          # PDFå‰å‡¦ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ gemini_ocr_service.py        # Gemini OCR
â”‚   â”‚   â”‚   â”œâ”€â”€ ocr_orchestrator.py          # OCRå…¨ä½“ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ translator_base.py           # ç¿»è¨³åŸºåº•ã‚¯ãƒ©ã‚¹
â”‚   â”‚   â”‚   â”œâ”€â”€ claude_translator.py         # Claudeç¿»è¨³
â”‚   â”‚   â”‚   â”œâ”€â”€ gemini_translator.py         # Geminiç¿»è¨³
â”‚   â”‚   â”‚   â””â”€â”€ translation_orchestrator.py  # ç¿»è¨³å…¨ä½“ç®¡ç†
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py                   # Pydanticãƒ¢ãƒ‡ãƒ«
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ supabase_client.py           # Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ local_db.py                  # ãƒ­ãƒ¼ã‚«ãƒ«DBï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ local_storage.py             # ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ retry.py                     # ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ logging_config.py            # ãƒ­ã‚®ãƒ³ã‚°è¨­å®šï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”‚   â””â”€â”€ error_handlers.py            # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ static/                          # WebUIç”¨é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”œâ”€â”€ templates/                       # WebUIç”¨HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â””â”€â”€ exceptions.py                    # ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ tests/                               # ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”œâ”€â”€ test_gemini_ocr_service.py
â”‚   â”‚   â”œâ”€â”€ test_gemini_translator.py
â”‚   â”‚   â”œâ”€â”€ test_claude_translator.py
â”‚   â”‚   â”œâ”€â”€ test_api_upload.py
â”‚   â”‚   â”œâ”€â”€ test_api_status.py
â”‚   â”‚   â””â”€â”€ test_ocr_orchestrator.py
â”‚   â”‚
â”‚   â”œâ”€â”€ launcher.py                          # ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³èµ·å‹•ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ pytest.ini
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ .env.example
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ page.tsx                         # ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”œâ”€â”€ layout.tsx                       # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â”œâ”€â”€ upload/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx                     # ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒšãƒ¼ã‚¸ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚   â””â”€â”€ jobs/
â”‚   â”‚       â””â”€â”€ [id]/
â”‚   â”‚           â””â”€â”€ page.tsx                 # ã‚¸ãƒ§ãƒ–è©³ç´°ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ui/                              # shadcn/ui
â”‚   â”‚   â”œâ”€â”€ FileUploader.tsx                 # ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ€ãƒ¼
â”‚   â”‚   â”œâ”€â”€ OCRProgress.tsx                  # OCRé€²æ—è¡¨ç¤º
â”‚   â”‚   â”œâ”€â”€ TranslationProgress.tsx          # ç¿»è¨³é€²æ—è¡¨ç¤º
â”‚   â”‚   â”œâ”€â”€ TranslationEngineSelector.tsx    # ã‚¨ãƒ³ã‚¸ãƒ³é¸æŠ
â”‚   â”‚   â””â”€â”€ MarkdownViewer.tsx               # ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¡¨ç¤º
â”‚   â”‚
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ supabase.ts                      # Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â””â”€â”€ api.ts                           # APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ next.config.js
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ textbook-translation-app-design.md   # ã“ã®è¨­è¨ˆæ›¸
â”‚   â”œâ”€â”€ api-reference.md                     # APIä»•æ§˜
â”‚   â””â”€â”€ user-guide.md                        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ‰
â”‚
â”œâ”€â”€ samples/
â”‚   â”œâ”€â”€ pdf/
â”‚   â”‚   â”œâ”€â”€ horizontal/                      # æ¨ªæ›¸ãã‚µãƒ³ãƒ—ãƒ«
â”‚   â”‚   â””â”€â”€ vertical/                        # ç¸¦æ›¸ãã‚µãƒ³ãƒ—ãƒ«
â”‚   â””â”€â”€ README.md
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_gemini_ocr.py
â”‚   â”œâ”€â”€ test_claude_translator.py
â”‚   â”œâ”€â”€ test_gemini_translator.py
â”‚   â””â”€â”€ test_integration.py
â”‚
â”œâ”€â”€ .gitignore
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
```

---

## ğŸš€ å®Ÿè£…çŠ¶æ³

### âœ… Phase 1: åŸºæœ¬æ©Ÿèƒ½ï¼ˆå®Œäº†ï¼‰

#### é”æˆå†…å®¹
- âœ… PDF â†’ OCR â†’ æ—¥æœ¬èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ç”Ÿæˆ
- âœ… æ—¥æœ¬èªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ â†’ å¤šè¨€èªç¿»è¨³
- âœ… WebUIï¼ˆFastAPIå†…è”µï¼‰

#### å®Œäº†ã‚¿ã‚¹ã‚¯
- [x] è¦ä»¶å®šç¾©ãƒ»è¨­è¨ˆæ›¸ä½œæˆ
- [x] ãƒ­ãƒ¼ã‚«ãƒ«DB/ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®Ÿè£…ï¼ˆSupabaseä¸è¦ï¼‰
- [x] ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰åŸºç›¤æ§‹ç¯‰ï¼ˆFastAPI + WebUIï¼‰
- [x] Gemini OCRå®Ÿè£…ï¼ˆ2.5/3.0åˆ‡ã‚Šæ›¿ãˆå¯¾å¿œï¼‰
- [x] Claudeç¿»è¨³å®Ÿè£…
- [x] ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰åŸºæœ¬UIï¼ˆNext.jsï¼‰
- [x] çµ±åˆãƒ†ã‚¹ãƒˆ

### âœ… Phase 2: ã‚¨ãƒ³ã‚¸ãƒ³é¸æŠï¼†å¤šè¨€èªå¯¾å¿œï¼ˆå®Œäº†ï¼‰

#### é”æˆå†…å®¹
- âœ… Geminiç¿»è¨³å®Ÿè£…
- âœ… Gemini 2.5/3.0åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
- âœ… å¤šè¨€èªå¯¾å¿œï¼ˆè‹±èªã€ä¸­å›½èªã€éŸ“å›½èªç­‰ï¼‰

#### å®Œäº†ã‚¿ã‚¹ã‚¯
- [x] Geminiç¿»è¨³å®Ÿè£…
- [x] ã‚¨ãƒ³ã‚¸ãƒ³åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ï¼ˆ`USE_GEMINI_3`ç’°å¢ƒå¤‰æ•°ï¼‰
- [x] è¤‡æ•°è¨€èªã‚µãƒãƒ¼ãƒˆ
- [x] ãƒãƒƒãƒç¿»è¨³æ©Ÿèƒ½

### âœ… Phase 3: å“è³ªå‘ä¸Šï¼†æœ€é©åŒ–ï¼ˆå®Œäº†ï¼‰

#### é”æˆå†…å®¹
- âœ… ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
- âœ… ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½å®Ÿè£…
- âœ… HTML/PDFå‡ºåŠ›æ©Ÿèƒ½

#### å®Œäº†ã‚¿ã‚¹ã‚¯
- [x] ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ï¼ˆexponential backoffï¼‰
- [x] ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–å®Ÿè£…
- [x] ãƒ­ã‚®ãƒ³ã‚°è¨­å®š
- [x] HTML/PDFç”Ÿæˆæ©Ÿèƒ½
- [x] ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ•´å‚™

### ğŸ”„ Phase 4: è¿½åŠ æ©Ÿèƒ½ãƒ»æ”¹å–„ï¼ˆé€²è¡Œä¸­ï¼‰

#### æ®‹ã‚¿ã‚¹ã‚¯
- [ ] ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Œæˆï¼ˆNext.jsï¼‰
  - [ ] ç¿»è¨³çµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸
  - [ ] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰UI
  - [ ] ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºæ”¹å–„
- [ ] æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™
  - [ ] Supabaseçµ±åˆãƒ†ã‚¹ãƒˆ
  - [ ] Vercelãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š
  - [ ] Dockerè¨­å®š

---

## âš™ï¸ è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«

### ç’°å¢ƒå¤‰æ•°ï¼ˆ.envï¼‰

#### å¿…é ˆè¨­å®š
```bash
# Google Gemini API (å¿…é ˆ)
GEMINI_API_KEY=your_gemini_api_key

# Anthropic Claude API (å¿…é ˆ)
CLAUDE_API_KEY=your_claude_api_key
```

#### ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«è¨­å®šï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œæ™‚ã¯ä¸è¦ï¼‰
```bash
# Supabaseï¼ˆæœ¬ç•ªç’°å¢ƒã§ä½¿ç”¨ã™ã‚‹å ´åˆã®ã¿è¨­å®šï¼‰
# ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã¯JSONãƒ™ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ä¸è¦
SUPABASE_URL=
SUPABASE_KEY=
SUPABASE_SERVICE_KEY=
```

#### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰è¨­å®š
```bash
# Backend
BACKEND_PORT=8000
BACKEND_HOST=0.0.0.0

# CORS
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8000

# File Upload
MAX_FILE_SIZE_MB=50
UPLOAD_DIR=uploads

# Gemini ãƒãƒ¼ã‚¸ãƒ§ãƒ³é¸æŠ
# USE_GEMINI_3=true â†’ Gemini 3.0 Pro (èª²é‡‘å¿…è¦ã€é«˜ç²¾åº¦)
# USE_GEMINI_3=false â†’ Gemini 2.5 Pro (ç„¡æ–™æ ã‚ã‚Šã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)
USE_GEMINI_3=false
```

#### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰è¨­å®šï¼ˆNext.jsä½¿ç”¨æ™‚ï¼‰
```bash
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co  # ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key  # ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«
```

### requirements.txt
```
fastapi==0.109.0
uvicorn[standard]==0.27.0
google-genai>=1.0.0                # Gemini SDK (æœ€æ–°ç‰ˆ)
anthropic==0.18.0
pdf2image==1.17.0
Pillow==10.2.0
python-multipart==0.0.6
pydantic==2.5.3
pydantic-settings==2.1.0
python-dotenv==1.0.0
httpx==0.26.0
aiofiles==23.2.1

# HTML/PDF generation
markdown==3.5.1
weasyprint==60.2
jinja2==3.1.2

# For testing
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0

# For Windows .exe build (ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«)
pyinstaller==6.3.0
```

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

```python
# tests/test_gemini_ocr.py

import pytest
from app.services.gemini_ocr_service import GeminiOCRService

@pytest.mark.asyncio
async def test_extract_page_vertical():
    """ç¸¦æ›¸ããƒšãƒ¼ã‚¸ã®OCRãƒ†ã‚¹ãƒˆ"""

    service = GeminiOCRService(api_key=os.getenv('GEMINI_API_KEY'))

    # ã‚µãƒ³ãƒ—ãƒ«ç”»åƒèª­ã¿è¾¼ã¿
    with open('tests/fixtures/vertical_sample.png', 'rb') as f:
        image_bytes = f.read()

    result = await service.extract_page(image_bytes, page_number=1, is_vertical=True)

    assert result['page_number'] == 1
    assert len(result['markdown_text']) > 0
    assert result['layout_info']['writing_mode'] == 'vertical'

@pytest.mark.asyncio
async def test_extract_figures():
    """å›³è§£æŠ½å‡ºãƒ†ã‚¹ãƒˆ"""

    service = GeminiOCRService(api_key=os.getenv('GEMINI_API_KEY'))

    # ãƒ†ã‚¹ãƒˆå®Ÿè£…...
```

```python
# tests/test_claude_translator.py

import pytest
from app.services.claude_translator import ClaudeTranslator

@pytest.mark.asyncio
async def test_translate_to_english():
    """æ—¥æœ¬èªâ†’è‹±èªç¿»è¨³ãƒ†ã‚¹ãƒˆ"""

    translator = ClaudeTranslator(api_key=os.getenv('CLAUDE_API_KEY'))

    source_text = """
# ç¬¬1ç«  ã¯ã˜ã‚ã«

ã“ã‚Œã¯æ•™ç§‘æ›¸ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚

![å›³1](figures/fig1.png)
"""

    result = await translator.translate(source_text, target_language='en')

    assert 'Chapter 1' in result or '# Introduction' in result
    assert '![Figure 1]' in result or '![Fig 1]' in result
```

### çµ±åˆãƒ†ã‚¹ãƒˆ

```python
# tests/test_integration.py

import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_full_workflow():
    """å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ"""

    async with AsyncClient(base_url="http://localhost:8000") as client:
        # 1. PDFã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        with open('tests/fixtures/sample.pdf', 'rb') as f:
            response = await client.post(
                '/api/upload',
                files={'file': ('sample.pdf', f, 'application/pdf')},
                data={'is_vertical': 'true'}
            )

        assert response.status_code == 200
        job_id = response.json()['job_id']

        # 2. OCRå®Œäº†å¾…æ©Ÿ
        for _ in range(60):  # æœ€å¤§60ç§’å¾…æ©Ÿ
            response = await client.get(f'/api/jobs/{job_id}')
            if response.json()['job']['ocr_status'] == 'completed':
                break
            await asyncio.sleep(1)

        assert response.json()['job']['ocr_status'] == 'completed'

        # 3. ç¿»è¨³é–‹å§‹
        response = await client.post('/api/translate', json={
            'job_id': job_id,
            'target_language': 'en',
            'translator_engine': 'claude'
        })

        assert response.status_code == 200
        output_id = response.json()['output_id']

        # 4. ç¿»è¨³å®Œäº†å¾…æ©Ÿ
        for _ in range(120):
            response = await client.get(f'/api/outputs/{output_id}')
            if response.json()['status'] == 'completed':
                break
            await asyncio.sleep(1)

        assert response.json()['status'] == 'completed'

        # 5. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        response = await client.get(f'/api/download/{output_id}/markdown')
        assert response.status_code == 200
        assert 'text/markdown' in response.headers['content-type']
```

---

## ğŸ’° ã‚³ã‚¹ãƒˆè©¦ç®—

### Gemini APIï¼ˆOCRï¼‰
- **ãƒ¢ãƒ‡ãƒ«**: gemini-2.5-pro-latest
- **æ–™é‡‘**:
  - å…¥åŠ›: $1.25 / 1M tokensï¼ˆç”»åƒå«ã‚€ï¼‰
  - å‡ºåŠ›: $5.00 / 1M tokens
- **ä¾‹**: 50ãƒšãƒ¼ã‚¸PDFï¼ˆç”»åƒ50æšã€å„ãƒšãƒ¼ã‚¸ç´„2,000ãƒˆãƒ¼ã‚¯ãƒ³ç›¸å½“ï¼‰
  - å…¥åŠ›: 100K tokens Ã— $1.25 / 1M = $0.125
  - å‡ºåŠ›: 10K tokens Ã— $5.00 / 1M = $0.05
  - **åˆè¨ˆ**: **$0.175**

### ç¿»è¨³ã‚³ã‚¹ãƒˆæ¯”è¼ƒ

#### Claude Sonnet 4.5
- **å…¥åŠ›**: $3.00 / 1M tokens
- **å‡ºåŠ›**: $15.00 / 1M tokens
- **ä¾‹**: 50ãƒšãƒ¼ã‚¸ï¼ˆç´„10,000 tokenså…¥åŠ›ã€10,000 tokenså‡ºåŠ›ï¼‰
  - å…¥åŠ›: 10K Ã— $3 / 1M = $0.03
  - å‡ºåŠ›: 10K Ã— $15 / 1M = $0.15
  - **åˆè¨ˆ**: **$0.18**

#### Gemini 2.5 Flash
- **å…¥åŠ›**: $0.075 / 1M tokens
- **å‡ºåŠ›**: $0.30 / 1M tokens
- **ä¾‹**: 50ãƒšãƒ¼ã‚¸ï¼ˆç´„10,000 tokenså…¥åŠ›ã€10,000 tokenså‡ºåŠ›ï¼‰
  - å…¥åŠ›: 10K Ã— $0.075 / 1M = $0.00075
  - å‡ºåŠ›: 10K Ã— $0.30 / 1M = $0.003
  - **åˆè¨ˆ**: **$0.004**

### ç·ã‚³ã‚¹ãƒˆè©¦ç®—ï¼ˆ50ãƒšãƒ¼ã‚¸æ•™ç§‘æ›¸ï¼‰

| å‡¦ç† | ã‚³ã‚¹ãƒˆ |
|------|--------|
| OCRï¼ˆGemini 2.5 Proï¼‰ | $0.175 |
| ç¿»è¨³ï¼ˆClaude Sonnetï¼‰ | $0.18 |
| ç¿»è¨³ï¼ˆGemini 2.5 Flashï¼‰ | $0.004 |
| **åˆè¨ˆï¼ˆClaudeä½¿ç”¨æ™‚ï¼‰** | **$0.355** |
| **åˆè¨ˆï¼ˆGeminiä½¿ç”¨æ™‚ï¼‰** | **$0.179** |

### æ¨å¥¨æˆ¦ç•¥
- **å“è³ªé‡è¦–**: OCRï¼ˆGemini 2.5 Proï¼‰ + ç¿»è¨³ï¼ˆClaudeï¼‰ = **$0.36/50p**
- **ã‚³ã‚¹ãƒˆé‡è¦–**: OCRï¼ˆGemini 2.5 Proï¼‰ + ç¿»è¨³ï¼ˆGemini 2.5 Flashï¼‰ = **$0.18/50p**
- **ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰**: åˆç¨¿Gemini Flash â†’ Claudeæ ¡æ­£

---

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

### ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
- MIMEã‚¿ã‚¤ãƒ—æ¤œè¨¼
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™ï¼ˆ50MBï¼‰
- ã‚¦ã‚¤ãƒ«ã‚¹ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆå°†æ¥çš„ã«ï¼‰

### APIèªè¨¼
- Supabase Authä½¿ç”¨
- JWT ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
- RLSï¼ˆRow Level Securityï¼‰è¨­å®š

### ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼
- ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰PDF: å‡¦ç†å¾Œ30æ—¥ã§è‡ªå‹•å‰Šé™¤
- å€‹äººæƒ…å ±ä¿è­·æ³•å¯¾å¿œ

---

## ğŸ“Š ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

### ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
- OCRæˆåŠŸç‡/å¤±æ•—ç‡
- ç¿»è¨³æˆåŠŸç‡/å¤±æ•—ç‡
- å¹³å‡å‡¦ç†æ™‚é–“
- APIã‚³ã‚¹ãƒˆ

### ãƒ­ã‚°ç®¡ç†
- æ§‹é€ åŒ–ãƒ­ã‚°ï¼ˆJSONï¼‰
- ã‚¨ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

---

## ğŸ“– ä»Šå¾Œã®æ‹¡å¼µè¨ˆç”»

### Phase 4ä»¥é™
- [ ] ãƒãƒƒãƒå‡¦ç†ï¼ˆè¤‡æ•°PDFä¸€æ‹¬å‡¦ç†ï¼‰
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸æ©Ÿèƒ½
- [ ] HTML/PDFå‡ºåŠ›å¼·åŒ–
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
- [ ] ç¿»è¨³ãƒ¡ãƒ¢ãƒª
- [ ] å”èª¿ç·¨é›†æ©Ÿèƒ½

---

## ğŸ“ ã¾ã¨ã‚

### è¨­è¨ˆã®ãƒã‚¤ãƒ³ãƒˆ

1. **Markerã‹ã‚‰ã®è„±å´**
   - ç¸¦æ›¸ããƒ»æ¨ªæ›¸ããƒ»æ··åœ¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«å¯¾å¿œã™ã‚‹ãŸã‚Geminiæ¡ç”¨
   - æ›¸å­—æ–¹å‘ã®è‡ªå‹•åˆ¤å®šï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šä¸è¦ï¼‰
   - OCRã¨ç¿»è¨³ã®å®Œå…¨åˆ†é›¢

2. **ãƒã‚¹ã‚¿ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«æ–¹å¼**
   - 1å›ã®OCRã§è¤‡æ•°è¨€èªå¯¾å¿œ
   - ã‚³ã‚¹ãƒˆå‰Šæ¸›ã¨ä¸€è²«æ€§ã®ä¸¡ç«‹

3. **ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³é¸æŠ**
   - Claude: å“è³ªé‡è¦–ï¼ˆæ¨å¥¨ï¼‰
   - Gemini: ã‚³ã‚¹ãƒˆé‡è¦–
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠå¯èƒ½

4. **æ‹¡å¼µæ€§**
   - æ–°è¨€èªè¿½åŠ ãŒå®¹æ˜“
   - æ–°ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³ã®è¿½åŠ ãŒå®¹æ˜“
   - ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼è¨­è¨ˆ

---

**ä½œæˆæ—¥**: 2025å¹´1æœˆ14æ—¥
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0
**å¯¾è±¡**: æ•™ç§‘æ›¸ç¿»è¨³ã‚¢ãƒ—ãƒªï¼ˆGeminiãƒ™ãƒ¼ã‚¹ï¼‰
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: è¨­è¨ˆå®Œäº†ã€å®Ÿè£…æœªç€æ‰‹
